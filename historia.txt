Este es el contenido inicial de este archivo

Primera linea de contenido

00. Configurar nuestra cuenta de git (repositorio local)
git config -l       (ver la configuración actual)
git config --global user.name "Nombre del usuario"
git config --global user.email "email"

0. Inicializar un repositorio de git
git init

1. Agregar un archivo al staging área (seguimiento/modificado)
git add nombreArchivo
git add .  (todos los archivos con cambios/sin seguimiento)

2. Sacar un archivo de staging area (sin seguimiento)
git rm --cached nombreArchivo

3. Enviar un archivo al repositorio (Historial de cambios)
git commit -m "mensaje del commit"

4. Mostrar todo el log de commits de nuestro proyecto
git log

5. Analizar los cambios en los archivos del proyecto
git show

6. Analizar los cambios entre dos commits
git diff commitHistoria commitBase (base por lo general es el HEAD)

7. Analizar los cambios que hay en el directorio de trabajo VS staging
git diff        (Tenemos agregado un archivo en el staging, pero este se le han añadido nuevos cambios, es decir, se agregó, luego se modifico)
                Esto obliga a que los cambios más recientes se tienen que enviar al staging

8. Volver en el tiempo
git checkout hashCommit nombreArchivo   (volver a un estado anterior este archivo)
git checkout master nombreArchivo       (volver a la version mas reciente este archivo)
NOTA:
Si se desea conservar los cambios anteriores de un archivo, se realiza un commit.
Cuando un archivo se vuelve en el tiempo, realmente se esta modificando.

9. Deshacer commits (solo en repositorio local, se infiere que jamás se ha hecho un pull de estos en remoto)
git reset --hard hashCommit     (elimina los commits mas recientes del historial con todo y su contenido, es decir, elimina los cambios de nuestro directorio de trabajo --- es el mas destructivo)
git reset --soft hashCommit     (elimina los commits mas recientes del historial conservando sus cambios en el stagging -- sirve para hacer un commit mas general de esos cambios)
git reset hashCommit            (elimina el historial de commits del historial, conserva los cambios en el directorio -- sirve para añadir mas cosas y hacer un commit mas general de esos cambios)
git commit --amend -m "nuevo mensaje"       (modifica el mensaje del último commit)
git commit --amend --no-edit                (permite corregir el commit mas reciente con nuevos cambios cambios preparados en el staging - se nos olvido agregar cosas, o se nos fue un dato o archivo que forma parte del commit mas reciente)
git add -am "mensaje del commit"    Solo funciona con archivos existentes (para agregar nuevos el procedimiento es el tradicional)

10. Ramas (lineas de tiempo alternativas al proyecto)
git branch nombreRama        (Crear rama "se genera una copia exacta del commit más reciente para esa rama")
git checkout nombreRama      (Moverme hacia otra rama)
git branch                      (listar todas las ramas registradas en el repositorio)

11. Fusionar ramas
    NOTA:   SE DEBE POSICIONAR EN LA RAMA DONDE SE DESEA DEJAR CAER LOS CAMBIOS (Por lo generar es en master, main, developer)
            Al fusionar la rama, la rama anterior no se borra, sigue exisitendo. Pero el HEAD puede seguir avanzando en la historia, a tal grado que esa rama se quede solitaria, sin las nuevas actualizaciones. EN ESTE SENTIDO, SI DESEAMOS SEGUIR TRABAJANDO EN ESA RAMA, ES IMPORTANTE HACER UN MERGE, PARA TRAERNOS NUEVAMENTE TODOS LOS CAMBIOS MÁS RECIENTES A DICHA RAMA.
    Una fusión en si es un nuevo commit en la historia del proyecto, por eso si existen conflictos al fusionar (Que dos progrmaadores hayan modificado las mismas lineas de código), es importante atenderlos y hacer el commit de forma tradicional.
    
git merge nombreRamaAFisionar

12. Comunicar con Github
* Crear repositorio en Github
* Copiar el link https
git remote add origin url_https_link_repositorio    (añadir un repositorio remoto - llamado origin)
git push origin master      (empujar la rama master hacia el repositorio remoto - llamado origin)
git pull origen master      (traer el origen (repositorio remoto) hacia mi rama master (local))
git remote -v               (Listar los repositorios remotos conectados con mi repositorio local)

* Cuando el repositorio remoto ya tiene cambios (README, LICENCE) y queremos traer esa info por primera vez
git pull origen master --allow-unrelated-histories

Podemos tener registrados multiples repositorios remotos en un repositiorio local. Y el nombre es indiferente, pero generalmente se le denomina origin 


13. Generar claves SSH      (Una llave privada/publica - por cada computadora)
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"     (Generar claves SSH - Publica y Privada)
        Asignar un nombre al archivo cuando lo solicite, no es necesario añadir una contraseña o frase)
eval "$(ssh-agent -s)"        (Iniciar el agente para gestionar las claves en la computadora)

AGREGAR LA LLAVE PRIVADA AL SSH-AGENT DEL SISTEMA OPERATIVO

WINDOWS / LINUX
ssh-add ~/.ssh/nombreArchivoClavePrivada        (Por defecto, es id_rsa si no se asigno un nombre)

MAC OS
open ~/.ssh/config          (Abrir el archivo de configuración o crearlo si no existe - touch ~/.ssh/config)
Añadir lo siguiente al mismo
Host *
  AddKeysToAgent yes
  UseKeychain yes
  IdentityFile ~/.ssh/nombreArchivoClavePrivada     (id_rsa)

ssh-add -K ~/.ssh/nombreArchivoClavePrivada

14. Vincular Llave pública con Github
* Ir a settings / SSH and GPG KEY
* Añadir la nueva llave pública asociada con uno de nuestos PC      (abrir el id_rsa.pub con VSCode y copiar y gegar su contenido en el formulario de github)


14. Cambiar URL del repositorio remoto registrado
git remote set-url origin git@github.com:alexglzrys/hyperblog.git       (origin es el nombre que le dimos a nuestro repositorio remoto)

** SI TENEMOS VINCULADAS LAS CREDENCIALES SSH PUBLICAS CON GITHUB, LA PRIMERA VEZ NOS CUESTIONA SI ESTAMOS DE ACUERDO, EL RESTO, JAMÁS NOS PIDE EL PASSWORD"

15. Ver la historia completa de nuestro proyecto
git log --all --oneline --decorate --graph

* Podemos crear una alias de todos esos comandos largos
alias nombreComando="todo-el-comando-largo-y-feo"

nombreComando       (Invoca el comando asociado con este alias)


16. Tags        (Versiones de nuestro código)
(Crear un tag llamado v0.1 referenciado al commit más actual - Los tags tambien llevan un mensaje, pero no contenido modificado, es por ello que cuando hacemos status, no aparece nada. Son solo referencias hacia un commit en especifico. Por tanto, los tags son utiles en Github, por que hacen referencia a un punto especifico del proyecto. "version")
git tag -a v1.4 -m "my version 1.4"         
git tag         (Listar todos los tags en mi proyecto)
(Crear un tag asociado a un commit anterior en mi proyecto - se añade el hash al final del mismo)
git tag -a v0.1 -m "Primera versión del proyecto del curso de Git" aaf7452      
git show nombreTag      (Ver información completa de ese tag)
git show-ref --tags     (Ver un listado completo de todos los tags y su relación con los commits del proeycto)
git push origin --tags  (Empujar los tags hacia el repositorio remoto)
git pull origin --tags  (Traerme todos los tags definidos en el repositorio remoto)

(Eliminar un tag del repositorio - "Recordemos que tambien nos sirven como referencias - quizá lo creamos para indicar que teníamos que hacer algo en ese punto del proyecto")
git tag -d nombreTag

NOTA: SI ENVIAMOS LOS CAMBIOS A GITHUB EL TAG ELIMINADO EN NUESTRO REPOSITORIO LOCAL SEGUIRA ESTANDO PRESENTE EN GITHUB. ESTO SE DEBE A QUE GITHUB CONSIDERA LOS TAGS COMO RELEASES DEL PROYECTO, POR TANTO TENEMOS QUE FORZAR A SU ELIMINACION EN remoto

git push origin --delete nombreTagAEliminarEnRemoto
